/* #pragma can be used to instruct the compiler to genrate assembly source
   file (extension .src) instead of an object file */
//#pragma src       
#include <REG51.H> // path: \Keil\C51\INC, define SFR names
#include <intrins.h> // this is required for direct access to the NOP instruction: _nop_()

#define TIMER0	    0xE5F4
#define DELAY_INIT	64      // 640 ms

unsigned int delay_cnt;
unsigned int delay_value;

/* For guidelines on writing interrupt routines in C check
    Keil online help: Cx51 Compiler User's Guide -> Languasge Extensions ->
		Function Declarations -> Interrupt Functions.
   
   see also the assembly solution of this task */

void timer0 (void) interrupt 1 using 1{	// Int Vector at 000BH, Reg
										// Bank 1
			
  // code for saving and restoring of the CPU status will be generated by the compiler

  TL0 = (unsigned char) timer0;		// MOV 	TL0, #LOW timer0	; reload the timer
  TH0 = (unsigned char) (((unsigned int) timer0)>>8); // MOV 	TH0, #HIGH timer0
  delay_cnt --;		   // DJNZ	delay_cnt, t0_done		; check if it is time to switch the LED
  if (delay_cnt == 0) {
    delay_cnt = delay_value;  // MOV		delay_cnt, delay_value; reload the counter witgh the current delay

	P3 ^= 0xFF;	  // XRL		P3, #0FFh					; blink the LEDs
	P2 ^= 0xFF;	  // XRL		P2, #0FFh					; blink the LEDs
	P1 ^= 0xFF;	  // XRL		P1, #0FFh					; blink the LEDs
	P0 ^= 0xFF;	  // XRL		P0, #0FFh					; blink the LEDs
  }
}

/*------------------------------------------------
The main C function.  Program execution starts
here after stack initialization.
------------------------------------------------*/
void main (void) {

  // ;initialize the counter
  delay_value = DELAY_INIT;	   // MOV		delay_value, #delay_init
  delay_cnt = delay_value;	   // MOV		delay_cnt, delay_value
			
  // ; timer configuration			
  TL0 = (unsigned char) TIMER0;	 // MOV 	TL0, #LOW timer0	; initilize the timer for
  TH0 = (unsigned char) (((unsigned int) TIMER0)>>8);  // MOV 	TH0, #HIGH timer0	; 10 ms @ 12MHz oscillator
  TMOD = 0x01;	// MOV 	TMOD, #01h			; 16-Bit timer controlled by run-bit (TCON)
  TR0 = 1;  // SETB	TR0						; run the timer
			
  // ; interrupt configuration
  PT0 = 1;		 // SETB	PT0					; set timer0 interrupt to high priority
  ET0 = 1;		 // SETB	ET0					; enable timer0 interrupt
  EA = 1;		 // SETB	EA					; make sure the interrupts are not disabled

  while (1)   // :endless
  {
    PCON |= 0x01;	  // ORL		PCON, #01h			; go into idle mode
	_nop_ ();		  // NOP							; make sure in case of hardware reset
	_nop_ ();		  // NOP							; there is enough time for it to work (2 cycles)
   }		  // JMP		endless

}
